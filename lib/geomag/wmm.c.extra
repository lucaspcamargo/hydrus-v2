
int MAG_Grid(MAGtype_CoordGeodetic minimum, MAGtype_CoordGeodetic maximum, double
        cord_step_size, double altitude_step_size, double time_step, MAGtype_MagneticModel *MagneticModel, MAGtype_Geoid
        *Geoid, MAGtype_Ellipsoid Ellip, MAGtype_Date StartDate, MAGtype_Date EndDate, int ElementOption, int UncertaintyOption, int PrintOption, char *OutputFile)

/*This function calls WMM subroutines to generate a grid as defined by the user. The function may be used
to generate a grid of magnetic field elements, time series or a profile. The selected geomagnetic element
is either printed to the file GridResults.txt or to the screen depending on user option.

INPUT: minimum :Data structure with the following elements (minimum limits of the grid)
                                double lambda; (longitude)
                                double phi; ( geodetic latitude)
                                double HeightAboveEllipsoid; (height above the ellipsoid (HaE) )
                                double HeightAboveGeoid;(height above the Geoid )
                maximum : same as the above (maximum limist of the grid)
                step_size  : double  : spatial step size, in decimal degrees
                a_step_size : double  :  double altitude step size (km)
                step_time : double  : time step size (decimal years)
                StartDate :  data structure with the following elements used
                                        double DecimalYear;     ( decimal years )
                EndDate :	Same as the above;
                MagneticModel :	 data structure with the following elements
                        double EditionDate;
                        double epoch;       Base time of Geomagnetic model epoch (yrs)
                        char  ModelName[20];
                        double *Main_Field_Coeff_G;          C - Gauss coefficients of main geomagnetic model (nT)
                        double *Main_Field_Coeff_H;          C - Gauss coefficients of main geomagnetic model (nT)
                        double *Secular_Var_Coeff_G;  CD - Gauss coefficients of secular geomagnetic model (nT/yr)
                        double *Secular_Var_Coeff_H;  CD - Gauss coefficients of secular geomagnetic model (nT/yr)
                        int nMax;  Maximum degree of spherical harmonic model
                        int nMaxSecVar; Maxumum degree of spherical harmonic secular model
                        int SecularVariationUsed; Whether or not the magnetic secular variation vector will be needed by program
                Geoid :  data structure with the following elements
        Pointer to data structure Geoid with the following elements
                        int NumbGeoidCols ;   ( 360 degrees of longitude at 15 minute spacing )
                        int NumbGeoidRows ;   ( 180 degrees of latitude  at 15 minute spacing )
                        int NumbHeaderItems ;    ( min, max lat, min, max long, lat, long spacing )
                        int	ScaleFactor;    ( 4 grid cells per degree at 15 minute spacing  )
                        float *GeoidHeightBuffer;   (Pointer to the memory to store the Geoid elevation data )
                        int NumbGeoidElevs;    (number of points in the gridded file )
                        int  Geoid_Initialized ;  ( indicates successful initialization )
   Ellip  data  structure with the following elements
                        double a; semi-major axis of the ellipsoid
                        double b; semi-minor axis of the ellipsoid
                        double fla;  flattening
                        double epssq; first eccentricity squared
                        double eps;  first eccentricity
                        double re; mean radius of  ellipsoid
          ElementOption : int : Geomagnetic Element to print
 *        UncertaintyOption: int: 1-Append uncertainties.  Otherwise do not append uncertainties.
          PrintOption : int : 1 Print to File, Otherwise, print to screen

   OUTPUT: none (prints the output to a file )

   CALLS : MAG_AllocateModelMemory To allocate memory for model coefficients
      MAG_TimelyModifyMagneticModel This modifies the Magnetic coefficients to the correct date.
                  MAG_ConvertGeoidToEllipsoidHeight (&CoordGeodetic, &Geoid);   Convert height above msl to height above WGS-84 ellipsoid
                  MAG_GeodeticToSpherical Convert from geodeitic to Spherical Equations: 7-8, WMM Technical report
                  MAG_ComputeSphericalHarmonicVariables Compute Spherical Harmonic variables
                  MAG_AssociatedLegendreFunction Compute ALF  Equations 5-6, WMM Technical report
                  MAG_Summation Accumulate the spherical harmonic coefficients Equations 10:12 , WMM Technical report
                  MAG_RotateMagneticVector Map the computed Magnetic fields to Geodeitic coordinates Equation 16 , WMM Technical report
                  MAG_CalculateGeoMagneticElements Calculate the geoMagnetic elements, Equation 18 , WMM Technical report

 */
{
    int NumTerms;
    double a, b, c, d, PrintElement, ErrorElement = 0;

    MAGtype_MagneticModel *TimedMagneticModel;
    MAGtype_CoordSpherical CoordSpherical;
    MAGtype_MagneticResults MagneticResultsSph, MagneticResultsGeo, MagneticResultsSphVar, MagneticResultsGeoVar;
    MAGtype_SphericalHarmonicVariables *SphVariables;
    MAGtype_GeoMagneticElements GeoMagneticElements, Errors;
    MAGtype_LegendreFunction *LegendreFunction;
    MAGtype_Gradient Gradient;
    
    FILE *fileout = NULL;

    if(PrintOption == 1)
    {
        fileout = fopen(OutputFile, "w");
        if(!fileout)
        {
            printf("Error opening %s to write", OutputFile);
            return FALSE;
        }
    }



    if(fabs(cord_step_size) < 1.0e-10) cord_step_size = 99999.0; /*checks to make sure that the step_size is not too small*/
    if(fabs(altitude_step_size) < 1.0e-10) altitude_step_size = 99999.0;
    if(fabs(time_step) < 1.0e-10) time_step = 99999.0;


    NumTerms = ((MagneticModel->nMax + 1) * (MagneticModel->nMax + 2) / 2);
    TimedMagneticModel = MAG_AllocateModelMemory(NumTerms);
    LegendreFunction = MAG_AllocateLegendreFunctionMemory(NumTerms); /* For storing the ALF functions */
    SphVariables = MAG_AllocateSphVarMemory(MagneticModel->nMax);
    a = minimum.HeightAboveGeoid; /*sets the loop initialization values*/
    b = minimum.phi;
    c = minimum.lambda;
    d = StartDate.DecimalYear;



    for(minimum.HeightAboveGeoid = a; minimum.HeightAboveGeoid <= maximum.HeightAboveGeoid; minimum.HeightAboveGeoid += altitude_step_size) /* Altitude loop*/
    {

        for(minimum.phi = b; minimum.phi <= maximum.phi; minimum.phi += cord_step_size) /*Latitude loop*/
        {

            for(minimum.lambda = c; minimum.lambda <= maximum.lambda; minimum.lambda += cord_step_size) /*Longitude loop*/
            {
                if(Geoid->UseGeoid == 1)
                    MAG_ConvertGeoidToEllipsoidHeight(&minimum, Geoid); /* This converts the height above mean sea level to height above the WGS-84 ellipsoid */
                else
                    minimum.HeightAboveEllipsoid = minimum.HeightAboveGeoid;
                MAG_GeodeticToSpherical(Ellip, minimum, &CoordSpherical);
                MAG_ComputeSphericalHarmonicVariables(Ellip, CoordSpherical, MagneticModel->nMax, SphVariables); /* Compute Spherical Harmonic variables  */
                MAG_AssociatedLegendreFunction(CoordSpherical, MagneticModel->nMax, LegendreFunction); /* Compute ALF  Equations 5-6, WMM Technical report*/

                for(StartDate.DecimalYear = d; StartDate.DecimalYear <= EndDate.DecimalYear; StartDate.DecimalYear += time_step) /*Year loop*/
                {

                    MAG_TimelyModifyMagneticModel(StartDate, MagneticModel, TimedMagneticModel); /*This modifies the Magnetic coefficients to the correct date. */
                    MAG_Summation(LegendreFunction, TimedMagneticModel, *SphVariables, CoordSpherical, &MagneticResultsSph); /* Accumulate the spherical harmonic coefficients Equations 10:12 , WMM Technical report*/
                    MAG_SecVarSummation(LegendreFunction, TimedMagneticModel, *SphVariables, CoordSpherical, &MagneticResultsSphVar); /*Sum the Secular Variation Coefficients, Equations 13:15 , WMM Technical report  */
                    MAG_RotateMagneticVector(CoordSpherical, minimum, MagneticResultsSph, &MagneticResultsGeo); /* Map the computed Magnetic fields to Geodetic coordinates Equation 16 , WMM Technical report */
                    MAG_RotateMagneticVector(CoordSpherical, minimum, MagneticResultsSphVar, &MagneticResultsGeoVar); /* Map the secular variation field components to Geodetic coordinates, Equation 17 , WMM Technical report*/
                    MAG_CalculateGeoMagneticElements(&MagneticResultsGeo, &GeoMagneticElements); /* Calculate the Geomagnetic elements, Equation 18 , WMM Technical report */
                    MAG_CalculateGridVariation(minimum, &GeoMagneticElements);
                    MAG_CalculateSecularVariationElements(MagneticResultsGeoVar, &GeoMagneticElements); /*Calculate the secular variation of each of the Geomagnetic elements, Equation 19, WMM Technical report*/
                    MAG_WMMErrorCalc(GeoMagneticElements.H, &Errors);
                    
                    if(ElementOption >= 17)
                        MAG_Gradient(Ellip, minimum, TimedMagneticModel, &Gradient);

                    switch(ElementOption) {
                        case 1:
                            PrintElement = GeoMagneticElements.Decl; /*1. Angle between the magnetic field vector and true north, positive east*/
                            ErrorElement = Errors.Decl;
                            break;
                        case 2:
                            PrintElement = GeoMagneticElements.Incl; /*2. Angle between the magnetic field vector and the horizontal plane, positive downward*/
                            ErrorElement = Errors.Incl;                            
                            break;
                        case 3:
                            PrintElement = GeoMagneticElements.F; /*3. Magnetic Field Strength*/
                            ErrorElement = Errors.F;
                            break;
                        case 4:
                            PrintElement = GeoMagneticElements.H; /*4. Horizontal Magnetic Field Strength*/
                            ErrorElement = Errors.H;
                            break;
                        case 5:
                            PrintElement = GeoMagneticElements.X; /*5. Northern component of the magnetic field vector*/
                            ErrorElement = Errors.X;
                            break;
                        case 6:
                            PrintElement = GeoMagneticElements.Y; /*6. Eastern component of the magnetic field vector*/
                            ErrorElement = Errors.Y;
                            break;
                        case 7:
                            PrintElement = GeoMagneticElements.Z; /*7. Downward component of the magnetic field vector*/
                            ErrorElement = Errors.Z;
                            break;
                        case 8:
                            PrintElement = GeoMagneticElements.GV; /*8. The Grid Variation*/
                            ErrorElement = Errors.Decl;
                            break;
                        case 9:
                            PrintElement = GeoMagneticElements.Decldot * 60; /*9. Yearly Rate of change in declination*/
                            UncertaintyOption = 0;
                            break;
                        case 10:
                            PrintElement = GeoMagneticElements.Incldot * 60; /*10. Yearly Rate of change in inclination*/
                            UncertaintyOption = 0;
                            break;
                        case 11:
                            PrintElement = GeoMagneticElements.Fdot; /*11. Yearly rate of change in Magnetic field strength*/
                            UncertaintyOption = 0;
                            break;
                        case 12:
                            PrintElement = GeoMagneticElements.Hdot; /*12. Yearly rate of change in horizontal field strength*/
                            UncertaintyOption = 0;
                            break;
                        case 13:
                            PrintElement = GeoMagneticElements.Xdot; /*13. Yearly rate of change in the northern component*/
                            UncertaintyOption = 0;
                            break;
                        case 14:
                            PrintElement = GeoMagneticElements.Ydot; /*14. Yearly rate of change in the eastern component*/
                            UncertaintyOption = 0;
                            break;
                        case 15:
                            PrintElement = GeoMagneticElements.Zdot; /*15. Yearly rate of change in the downward component*/
                            UncertaintyOption = 0;
                            break;
                        case 16:
                            PrintElement = GeoMagneticElements.GVdot;
                            UncertaintyOption = 0;
                            /*16. Yearly rate of change in grid variation*/;
                            break;
                        case 17:
                            PrintElement = Gradient.GradPhi.X;
                            UncertaintyOption = 0;
                            break;
                        case 18:
                            PrintElement = Gradient.GradPhi.Y;
                            UncertaintyOption = 0;
                            break;
                        case 19:
                            PrintElement = Gradient.GradPhi.Z;
                            UncertaintyOption = 0;
                            break;
                        case 20:
                            PrintElement = Gradient.GradLambda.X;
                            UncertaintyOption = 0;
                            break;
                        case 21:
                            PrintElement = Gradient.GradLambda.Y;
                            UncertaintyOption = 0;
                            break;
                        case 22:
                            PrintElement = Gradient.GradLambda.Z;
                            UncertaintyOption = 0;
                            break;
                        case 23:
                            PrintElement = Gradient.GradZ.X;
                            UncertaintyOption = 0;
                            break;
                        case 24:
                            PrintElement = Gradient.GradZ.Y;
                            UncertaintyOption = 0;
                            break;
                        case 25:
                            PrintElement = Gradient.GradZ.Z;
                            UncertaintyOption = 0;
                            break;
                        default:
                            PrintElement = GeoMagneticElements.Decl; /* 1. Angle between the magnetic field vector and true north, positive east*/
                            ErrorElement = Errors.Decl;
                    }

                    if(Geoid->UseGeoid == 1)
                    {
                        if(PrintOption == 1) fprintf(fileout, "%5.2f %6.2f %8.4f %7.2f %10.2f", minimum.phi, minimum.lambda, minimum.HeightAboveGeoid, StartDate.DecimalYear, PrintElement);
                        else printf("%5.2f %6.2f %8.4f %7.2f %10.2f", minimum.phi, minimum.lambda, minimum.HeightAboveGeoid, StartDate.DecimalYear, PrintElement);
                    } else
                    {
                        if(PrintOption == 1) fprintf(fileout, "%5.2f %6.2f %8.4f %7.2f %10.2f", minimum.phi, minimum.lambda, minimum.HeightAboveEllipsoid, StartDate.DecimalYear, PrintElement);
                        else printf("%5.2f %6.2f %8.4f %7.2f %10.2f", minimum.phi, minimum.lambda, minimum.HeightAboveEllipsoid, StartDate.DecimalYear, PrintElement);
                    }
                    if(UncertaintyOption == 1) {
                        if(PrintOption == 1) fprintf(fileout, " %7.2f", ErrorElement);
                        else printf(" %7.2f", ErrorElement);
                    }
                    if(PrintOption == 1) fprintf(fileout, "\n");
                    else printf("\n"); /* Complete line */

                     /**Below can be used for XYZ Printing format (longitude latitude output_data)
                     *  fprintf(fileout, "%5.2f %6.2f %10.4f\n", minimum.lambda, minimum.phi, PrintElement); **/
                        
                } /* year loop */

            } /*Longitude Loop */

        } /* Latitude Loop */

    } /* Altitude Loop */
    if(PrintOption == 1) fclose(fileout);


    MAG_FreeMagneticModelMemory(TimedMagneticModel);
    MAG_FreeLegendreMemory(LegendreFunction);
    MAG_FreeSphVarMemory(SphVariables);

    return TRUE;
} /*MAG_Grid*/


/******************************************************************************
 ********************************User Interface********************************
 * This grouping consists of functions which interact with the directly with 
 * the user and are generally specific to the XXX_point.c, XXX_grid.c, and    
 * XXX_file.c programs. They deal with input from and output to the user.
 ******************************************************************************/

void MAG_Error_orig(int control)

/*This prints WMM errors.
INPUT     control     Error look up number
OUTPUT	  none
CALLS : none

 */
{
    switch(control) {
        case 1:
            printf("\nError allocating in MAG_LegendreFunctionMemory.\n");
            break;
        case 2:
            printf("\nError allocating in MAG_AllocateModelMemory.\n");
            break;
        case 3:
            printf("\nError allocating in MAG_InitializeGeoid\n");
            break;
        case 4:
            printf("\nError in setting default values.\n");
            break;
        case 5:
            printf("\nError initializing Geoid.\n");
            break;
        case 6:
            printf("\nError opening WMM.COF\n.");
            break;
        case 7:
            printf("\nError opening WMMSV.COF\n.");
            break;
        case 8:
            printf("\nError reading Magnetic Model.\n");
            break;
        case 9:
            printf("\nError printing Command Prompt introduction.\n");
            break;
        case 10:
            printf("\nError converting from geodetic co-ordinates to spherical co-ordinates.\n");
            break;
        case 11:
            printf("\nError in time modifying the Magnetic model\n");
            break;
        case 12:
            printf("\nError in Geomagnetic\n");
            break;
        case 13:
            printf("\nError printing user data\n");\
			break;
        case 14:
            printf("\nError allocating in MAG_SummationSpecial\n");
            break;
        case 15:
            printf("\nError allocating in MAG_SecVarSummationSpecial\n");
            break;
        case 16:
            printf("\nError in opening EGM9615.BIN file\n");
            break;
        case 17:
            printf("\nError: Latitude OR Longitude out of range in MAG_GetGeoidHeight\n");
            break;
        case 18:
            printf("\nError allocating in MAG_PcupHigh\n");
            break;
        case 19:
            printf("\nError allocating in MAG_PcupLow\n");
            break;
        case 20:
            printf("\nError opening coefficient file\n");
            break;
        case 21:
            printf("\nError: UnitDepth too large\n");
            break;
        case 22:
            printf("\nYour system needs Big endian version of EGM9615.BIN.  \n");
            printf("Please download this file from http://www.ngdc.noaa.gov/geomag/WMM/DoDWMM.shtml.  \n");
            printf("Replace the existing EGM9615.BIN file with the downloaded one\n");
            break;
    }
} /*MAG_Error*/

char MAG_GeomagIntroduction_EMM(MAGtype_MagneticModel *MagneticModel, char* VersionDate)
{
    char ans = 'h';
    printf("\n\n Welcome to the Enhanced Magnetic Model (EMM) %d C-Program\n\n", (int) MagneticModel->epoch);
    printf("             --- Model Release Date: 15 Dec %d ---\n", (int) MagneticModel->epoch - 1);
    printf("            --- Software Release Date: %s ---\n\n", VersionDate);
    printf("\n This program estimates the strength and direction of ");
    printf("\n Earth's main Magnetic field and crustal variation for a given point/area.");
    while(ans != 'c' && ans != 'C')
    {
        printf("\n Enter h for help and contact information or c to continue.");
        printf("\n >");
        scanf("%c%*[^\n]", &ans);
        getchar();

        if((ans == 'h') || (ans == 'H'))
        {
            printf("\n Help information ");

            printf("\n The Enhanced Magnetic Model (EMM) for %d", (int) MagneticModel->epoch);
            printf("\n is a model of Earth's main Magnetic and crustal field.  The EMM");
            printf("\n is recomputed every five (5) years, in years divisible by ");
            printf("\n five (i.e. 2010, 2015).  See the contact information below");
            printf("\n to obtain more information on the EMM and associated software.");
            printf("\n ");
            printf("\n Input required is the location in geodetic latitude and");
            printf("\n longitude (positive for northern latitudes and eastern ");
            printf("\n longitudes), geodetic altitude in meters, and the date of ");
            printf("\n interest in years.");

            printf("\n\n\n The program computes the estimated Magnetic Declination");
            printf("\n (Decl) which is sometimes called MagneticVAR, Inclination (Incl), Total");
            printf("\n Intensity (F or TI), Horizontal Intensity (H or HI), Vertical");
            printf("\n Intensity (Z), and Grid Variation (GV). Declination and Grid");
            printf("\n Variation are measured in units of degrees and are considered");
            printf("\n positive when east or north.  Inclination is measured in units");
            printf("\n of degrees and is considered positive when pointing down (into");
            printf("\n the Earth).  The WMM is reference to the WGS-84 ellipsoid and");
            printf("\n is valid for 5 years after the base epoch.");

            printf("\n\n\n It is very important to note that a degree and  order 720 model,");
            printf("\n such as EMM, describes the long  wavelength spatial Magnetic ");
            printf("\n fluctuations due to  Earth's core.  Also included in the EMM series");
            printf("\n models are intermediate and short wavelength spatial fluctuations ");
            printf("\n that originate in Earth's mantle and crust. Not included in");
            printf("\n the model are temporal fluctuations of Magnetospheric and ionospheric");
            printf("\n origin. On the days during and immediately following Magnetic storms,");
            printf("\n temporal fluctuations can cause substantial deviations of the Geomagnetic");
            printf("\n field  from model  values.  If the required  declination accuracy  is");
            printf("\n more stringent than the EMM  series of models provide, the user is");
            printf("\n advised to request special (regional or local) surveys be performed");
            printf("\n and models prepared. Please make requests of this nature to the");
            printf("\n National Geospatial-Intelligence Agency (NGA) at the address below.");

            printf("\n\n\n Contact Information");

            printf("\n  Software and Model Support");
            printf("\n	National Geophysical Data Center");
            printf("\n	NOAA EGC/2");
            printf("\n	325 Broadway");
            printf("\n	Boulder, CO 80303 USA");
            printf("\n	Attn: Adam Woods or Manoj Nair");
            printf("\n	Phone:  (303) 497-6640 or -4642");
            printf("\n	Email:  geomag.models@noaa.gov \n");
        }
    }
    return ans;
}

char MAG_GeomagIntroduction_WMM(MAGtype_MagneticModel *MagneticModel, char *VersionDate)
/*Prints the introduction to the Geomagnetic program.  It needs the Magnetic model for the epoch.

 * INPUT  MagneticModel		: MAGtype_MagneticModel With Model epoch 	(input)
  OUTPUT ans   (char)  user selection
  CALLS : none
 */
{
    char help = 'h';
    char ans;
    printf("\n\n Welcome to the World Magnetic Model (WMM) %d C-Program\n\n", (int) MagneticModel->epoch);
    printf("              --- Model Release Date: 15 Dec %d ---\n", (int) MagneticModel->epoch - 1);
    printf("            --- Software Release Date: %s ---\n\n", VersionDate);
    printf("\n This program estimates the strength and direction of ");
    printf("\n Earth's main Magnetic field for a given point/area.");
    while(help != 'c' && help != 'C')
    {
        printf("\n Enter h for help and contact information or c to continue.");
        printf("\n >");
        scanf("%c%*[^\n]", &help);
        getchar();

        if((help == 'h') || (help == 'H'))
        {
            printf("\n Help information ");

            printf("\n The World Magnetic Model (WMM) for %d", (int) MagneticModel->epoch);
            printf("\n is a model of Earth's main Magnetic field.  The WMM");
            printf("\n is recomputed every five (5) years, in years divisible by ");
            printf("\n five (i.e. 2010, 2015).  See the contact information below");
            printf("\n to obtain more information on the WMM and associated software.");
            printf("\n ");
            printf("\n Input required is the location in geodetic latitude and");
            printf("\n longitude (positive for northern latitudes and eastern ");
            printf("\n longitudes), geodetic altitude in meters, and the date of ");
            printf("\n interest in years.");

            printf("\n\n\n The program computes the estimated Magnetic Declination");
            printf("\n (Decl) which is sometimes called MagneticVAR, Inclination (Incl), Total");
            printf("\n Intensity (F or TI), Horizontal Intensity (H or HI), Vertical");
            printf("\n Intensity (Z), and Grid Variation (GV). Declination and Grid");
            printf("\n Variation are measured in units of degrees and are considered");
            printf("\n positive when east or north.  Inclination is measured in units");
            printf("\n of degrees and is considered positive when pointing down (into");
            printf("\n the Earth).  The WMM is referenced to the WGS-84 ellipsoid and");
            printf("\n is valid for 5 years after the base epoch. Uncertainties for the");
            printf("\n WMM are one standard deviation uncertainties averaged over the globe.");
            printf("\n We represent the uncertainty as constant values in Incl, F, H, X,");
            printf("\n Y, and Z. Uncertainty in Declination varies depending on the strength");
            printf("\n of the horizontal field.  For more information see the WMM Technical");
            printf("\n Report.");
            
            printf("\n\n\n It is very important to note that a  degree and  order 12 model,");
            printf("\n such as WMM, describes only the long  wavelength spatial Magnetic ");
            printf("\n fluctuations due to  Earth's core.  Not included in the WMM series");
            printf("\n models are intermediate and short wavelength spatial fluctuations ");
            printf("\n that originate in Earth's mantle and crust. Consequently, isolated");
            printf("\n angular errors at various  positions on the surface (primarily over");
            printf("\n land, along continental margins and  over oceanic sea-mounts, ridges and");
            printf("\n trenches) of several degrees may be expected.  Also not included in");
            printf("\n the model are temporal fluctuations of Magnetospheric and ionospheric");
            printf("\n origin. On the days during and immediately following Magnetic storms,");
            printf("\n temporal fluctuations can cause substantial deviations of the Geomagnetic");
            printf("\n field  from model  values.  If the required  declination accuracy  is");
            printf("\n more stringent than the WMM  series of models provide, the user is");
            printf("\n advised to request special (regional or local) surveys be performed");
            printf("\n and models prepared. The World Magnetic Model is a joint product of");
            printf("\n the United States’ National Geospatial-Intelligence Agency (NGA) and");
            printf("\n the United Kingdom’s Defence Geographic Centre (DGC). The WMM was");
            printf("\n developed jointly by the National Geophysical Data Center (NGDC, Boulder");
            printf("\n CO, USA) and the British Geological Survey (BGS, Edinburgh, Scotland). ");

            printf("\n\n\n Contact Information");

            printf("\n  Software and Model Support");
            printf("\n	National Geophysical Data Center");
            printf("\n	NOAA EGC/2");
            printf("\n	325 Broadway");
            printf("\n	Boulder, CO 80303 USA");
            printf("\n	Attn: Manoj Nair or Arnaud Chulliat");
            printf("\n	Phone:  (303) 497-4642 or -6522"); 
            printf("\n	Email:  Geomag.Models@noaa.gov \n");
        }
    }
    ans = help;
    return ans;
} /*MAG_GeomagIntroduction_WMM*/


int MAG_GetUserGrid(MAGtype_CoordGeodetic *minimum, MAGtype_CoordGeodetic *maximum, double *step_size, double *a_step_size, double *step_time, MAGtype_Date
        *StartDate, MAGtype_Date *EndDate, int *ElementOption, int *PrintOption, char *OutputFile, MAGtype_Geoid *Geoid)

/* Prompts user to enter parameters to compute a grid - for use with the MAG_grid function
Note: The user entries are not validated before here. The function populates the input variables & data structures.

UPDATE : minimum Pointer to data structure with the following elements
                double lambda; (longitude)
                double phi; ( geodetic latitude)
                double HeightAboveEllipsoid; (height above the ellipsoid (HaE) )
                double HeightAboveGeoid;(height above the Geoid )

                maximum   -same as the above -MAG_USE_GEOID
                step_size  : double pointer : spatial step size, in decimal degrees
                a_step_size : double pointer :  double altitude step size (km)
                step_time : double pointer : time step size (decimal years)
                StartDate : pointer to data structure with the following elements updates
                                        double DecimalYear;     ( decimal years )
                EndDate :	Same as the above
CALLS : none


 */
{
    FILE *fileout;
    char filename[] = "GridProgramDirective.txt";
    char buffer[20];
    int dummy;

    printf("Please Enter Minimum Latitude (in decimal degrees):\n");
    fgets(buffer, 20, stdin);
    sscanf(buffer, "%lf", &minimum->phi);
    strcpy(buffer, "");
    printf("Please Enter Maximum Latitude (in decimal degrees):\n");
    fgets(buffer, 20, stdin);
    sscanf(buffer, "%lf", &maximum->phi);
    strcpy(buffer, "");
    printf("Please Enter Minimum Longitude (in decimal degrees):\n");
    fgets(buffer, 20, stdin);
    sscanf(buffer, "%lf", &minimum->lambda);
    strcpy(buffer, "");
    printf("Please Enter Maximum Longitude (in decimal degrees):\n");
    fgets(buffer, 20, stdin);
    sscanf(buffer, "%lf", &maximum->lambda);
    strcpy(buffer, "");
    printf("Please Enter Step Size (in decimal degrees):\n");
    fgets(buffer, 20, stdin);
    sscanf(buffer, "%lf", step_size);
    strcpy(buffer, "");
    printf("Select height (default : above MSL) \n1. Above Mean Sea Level\n2. Above WGS-84 Ellipsoid \n");
    fgets(buffer, 20, stdin);
    sscanf(buffer, "%d", &dummy);
    if(dummy == 2) Geoid->UseGeoid = 0;
    else Geoid->UseGeoid = 1;
    strcpy(buffer, "");
    if(Geoid->UseGeoid == 1)
    {
        printf("Please Enter Minimum Height above MSL (in km):\n");
        fgets(buffer, 20, stdin);
        sscanf(buffer, "%lf", &minimum->HeightAboveGeoid);
        strcpy(buffer, "");
        printf("Please Enter Maximum Height above MSL (in km):\n");
        fgets(buffer, 20, stdin);
        sscanf(buffer, "%lf", &maximum->HeightAboveGeoid);
        strcpy(buffer, "");
        printf("Please Enter height step size (in km):\n");
        fgets(buffer, 20, stdin);
        sscanf(buffer, "%lf", a_step_size);
        strcpy(buffer, "");
    } else
    {
        printf("Please Enter Minimum Height above the WGS-84 Ellipsoid (in km):\n");
        fgets(buffer, 20, stdin);
        sscanf(buffer, "%lf", &minimum->HeightAboveGeoid);
        minimum->HeightAboveEllipsoid = minimum->HeightAboveGeoid;
        strcpy(buffer, "");
        printf("Please Enter Maximum Height above the WGS-84 Ellipsoid (in km):\n");
        fgets(buffer, 20, stdin);
        sscanf(buffer, "%lf", &maximum->HeightAboveGeoid);
        maximum->HeightAboveEllipsoid = minimum->HeightAboveGeoid;
        strcpy(buffer, "");
        printf("Please Enter height step size (in km):\n");
        fgets(buffer, 20, stdin);
        sscanf(buffer, "%lf", a_step_size);
        strcpy(buffer, "");
    }
    printf("\nPlease Enter the decimal year starting time:\n");
    fgets(buffer, 20, stdin);
    sscanf(buffer, "%lf", &StartDate->DecimalYear);
    strcpy(buffer, "");
    printf("Please Enter the decimal year ending time:\n");
    fgets(buffer, 20, stdin);
    sscanf(buffer, "%lf", &EndDate->DecimalYear);
    strcpy(buffer, "");
    printf("Please Enter the time step size:\n");
    fgets(buffer, 20, stdin);
    sscanf(buffer, "%lf", step_time);
    strcpy(buffer, "");
    printf("Enter a geomagnetic element to print. Your options are:\n");
    printf(" 1. Declination	9.   Ddot\n 2. Inclination	10. Idot\n 3. F		11. Fdot\n 4. H		12. Hdot\n 5. X		13. Xdot\n 6. Y		14. Ydot\n 7. Z		15. Zdot\n 8. GV		16. GVdot\nFor gradients enter: 17\n");
    fgets(buffer, 20, stdin);
    sscanf(buffer, "%d", ElementOption);
    strcpy(buffer, "");
    if(*ElementOption == 17)
    {
        printf("Enter a gradient element to print. Your options are:\n");
        printf(" 1. dX/dphi \t2. dY/dphi \t3. dZ/dphi\n");
        printf(" 4. dX/dlambda \t5. dY/dlambda \t6. dZ/dlambda\n");
        printf(" 7. dX/dz \t8. dY/dz \t9. dZ/dz\n");
        strcpy(buffer, "");
        fgets(buffer, 32, stdin);
        sscanf(buffer, "%d", ElementOption);
        strcpy(buffer, "");
        *ElementOption+=16;
    }
    printf("Select output :\n");
    printf(" 1. Print to a file \n 2. Print to Screen\n");
    fgets(buffer, 20, stdin);
    sscanf(buffer, "%d", PrintOption);
    strcpy(buffer, "");
    fileout = fopen(filename, "a");
    if(*PrintOption == 1)
    {
        printf("Please enter output filename\nfor default ('GridResults.txt') press enter:\n");
        fgets(buffer, 20, stdin);
        if(strlen(buffer) <= 1)
        {
            strcpy(OutputFile, "GridResults.txt");
            fprintf(fileout, "\nResults printed in: GridResults.txt\n");
            strcpy(OutputFile, "GridResults.txt");
        } else
        {
            sscanf(buffer, "%s", OutputFile);
            fprintf(fileout, "\nResults printed in: %s\n", OutputFile);
        }
        /*strcpy(OutputFile, buffer);*/
        strcpy(buffer, "");
        /*sscanf(buffer, "%s", OutputFile);*/
    } else
        fprintf(fileout, "\nResults printed in Console\n");
    fprintf(fileout, "Minimum Latitude: %f\t\tMaximum Latitude: %f\t\tStep Size: %f\nMinimum Longitude: %f\t\tMaximum Longitude: %f\t\tStep Size: %f\n", minimum->phi, maximum->phi, *step_size, minimum->lambda, maximum->lambda, *step_size);
    if(Geoid->UseGeoid == 1)
        fprintf(fileout, "Minimum Altitude above MSL: %f\tMaximum Altitude above MSL: %f\tStep Size: %f\n", minimum->HeightAboveGeoid, maximum->HeightAboveGeoid, *a_step_size);
    else
        fprintf(fileout, "Minimum Altitude above MSL: %f\tMaximum Altitude above WGS-84 Ellipsoid: %f\tStep Size: %f\n", minimum->HeightAboveEllipsoid, maximum->HeightAboveEllipsoid, *a_step_size);
    fprintf(fileout, "Starting Date: %f\t\tEnding Date: %f\t\tStep Time: %f\n\n\n", StartDate->DecimalYear, EndDate->DecimalYear, *step_time);
    fclose(fileout);
    return TRUE;
}

int MAG_GetUserInput(MAGtype_MagneticModel *MagneticModel, MAGtype_Geoid *Geoid, MAGtype_CoordGeodetic *CoordGeodetic, MAGtype_Date *MagneticDate)

/*
This prompts the user for coordinates, and accepts many entry formats.
It takes the MagneticModel and Geoid as input and outputs the Geographic coordinates and Date as objects.
Returns 0 when the user wants to exit and 1 if the user enters valid input data.
INPUT :  MagneticModel  : Data structure with the following elements used here
                        double epoch;       Base time of Geomagnetic model epoch (yrs)
                : Geoid Pointer to data structure MAGtype_Geoid (used for converting HeightAboveGeoid to HeightABoveEllipsoid

OUTPUT: CoordGeodetic : Pointer to data structure. Following elements are updated
                        double lambda; (longitude)
                        double phi; ( geodetic latitude)
                        double HeightAboveEllipsoid; (height above the ellipsoid (HaE) )
                        double HeightAboveGeoid;(height above the Geoid )

                MagneticDate : Pointer to data structure MAGtype_Date with the following elements updated
                        int	Year; (If user directly enters decimal year this field is not populated)
                        int	Month;(If user directly enters decimal year this field is not populated)
                        int	Day; (If user directly enters decimal year this field is not populated)
                        double DecimalYear;      decimal years

CALLS: 	MAG_DMSstringToDegree(buffer, &CoordGeodetic->lambda); (The program uses this to convert the string into a decimal longitude.)
                MAG_ValidateDMSstringlong(buffer, Error_Message)
                MAG_ValidateDMSstringlat(buffer, Error_Message)
                MAG_Warnings
                MAG_ConvertGeoidToEllipsoidHeight
                MAG_DateToYear

 */
{
    char Error_Message[255];
    char buffer[40];
    char tmp;
    int i, j, a, b, c, done = 0;
    strcpy(buffer, ""); /*Clear the input    */
    printf("\nPlease enter latitude");
    printf("\nNorth Latitude positive, For example:");
    printf("\n30, 30, 30 (D,M,S) or 30.508 (Decimal Degrees) (both are north)\n");
    fgets(buffer, 40, stdin);
    for(i = 0, done = 0, j = 0; i <= 40 && !done; i++)
    {
        if(buffer[i] == '.')
        {
            j = sscanf(buffer, "%lf", &CoordGeodetic->phi);
            if(j == 1)
                done = 1;
            else
                done = -1;
        }
        if(buffer[i] == ',')
        {
            if(MAG_ValidateDMSstringlat(buffer, Error_Message))
            {
                MAG_DMSstringToDegree(buffer, &CoordGeodetic->phi);
                done = 1;
            } else
                done = -1;
        }
        if(buffer[i] == ' ')/* This detects if there is a ' ' somewhere in the string,
		if there is the program tries to interpret the input as Degrees Minutes Seconds.*/
        {
            if(MAG_ValidateDMSstringlat(buffer, Error_Message))
            {
                MAG_DMSstringToDegree(buffer, &CoordGeodetic->phi);
                done = 1;
            } else
                done = -1;
        }
        if(buffer[i] == '\0' || done == -1)
        {
            if(MAG_ValidateDMSstringlat(buffer, Error_Message) && done != -1)
            {
                sscanf(buffer, "%lf", &CoordGeodetic->phi);
                done = 1;
            } else
            {
                printf("%s", Error_Message);
                strcpy(buffer, "");
                printf("\nError encountered, please re-enter as '(-)DDD,MM,SS' or in Decimal Degrees DD.ddd:\n");
                fgets(buffer, 40, stdin);
                i = -1;
                done = 0;
            }
        }
    }
    strcpy(buffer, ""); /*Clear the input*/
    printf("\nPlease enter longitude");
    printf("\nEast longitude positive, West negative.  For example:");
    printf("\n-100.5 or -100, 30, 0 for 100.5 degrees west\n");
    fgets(buffer, 40, stdin);
    for(i = 0, done = 0, j = 0; i <= 40 && !done; i++)/*This for loop determines how the user is trying to enter their data, and makes sure that it is copied into the correct location*/
    {
        if(buffer[i] == '.') /*This detects if there is a '.' somewhere in the string, if there is the program tries to interpret the input as a double, and copies it to the longitude*/
        {
            j = sscanf(buffer, "%lf", &CoordGeodetic->lambda);
            if(j == 1)
                done = 1; /*This control ends the loop*/
            else
                done = -1; /*This copies an end string into the buffer so that the user is sent to the Re-enter input message*/
        }
        if(buffer[i] == ',')/*This detects if there is a ',' somewhere in the string, if there is the program tries to interpret the input as Degrees, Minutes, Seconds.*/
        {
            if(MAG_ValidateDMSstringlong(buffer, Error_Message))
            {
                MAG_DMSstringToDegree(buffer, &CoordGeodetic->lambda); /*The program uses this to convert the string into a decimal longitude.*/
                done = 1;
            } else
                done = -1;
        }
        if(buffer[i] == ' ')/* This detects if there is a ' ' somewhere in the string, if there is the program tries to interpret the input as Degrees Minutes Seconds.*/
        {
            if(MAG_ValidateDMSstringlong(buffer, Error_Message))
            {
                MAG_DMSstringToDegree(buffer, &CoordGeodetic->lambda);
                done = 1;
            } else
                done = -1;
        }
        if(buffer[i] == '\0' || done == -1) /*If the program reaches the end of the string before finding a "." or a "," or if its been sent by an error it does this*/
        {
            MAG_ValidateDMSstringlong(buffer, Error_Message); /*The program attempts to determine if all the characters in the string are legal, and then tries to interpret the string as a simple degree entry, like "0", or "67"*/
            if(MAG_ValidateDMSstringlong(buffer, Error_Message) && done != -1)
            {
                sscanf(buffer, "%lf", &CoordGeodetic->lambda);
                done = 1;
            } else /*The string is neither DMS, a decimal degree, or a simple degree input, or has some error*/
            {
                printf("%s", Error_Message);
                strcpy(buffer, ""); /*Clear the input*/
                printf("\nError encountered, please re-enter as '(-)DDD,MM,SS' or in Decimal Degrees DD.ddd:\n"); /*Request new input*/
                fgets(buffer, 40, stdin);
                i = -1; /*Restart the loop, at the end of this loop i will be incremented to 0, effectively restarting the loop*/
                done = 0;
            }
        }
    }
    printf("\nPlease enter height above mean sea level (in kilometers):\n[For height above WGS-84 Ellipsoid prefix E, for example (E20.1)]\n");
    done = 0;
    while(!done)
    {
        strcpy(buffer, "");
        fgets(buffer, 40, stdin);
        j = 0;
        if(buffer[0] == 'e' || buffer[0] == 'E') /* User entered height above WGS-84 ellipsoid, copy it to CoordGeodetic->HeightAboveEllipsoid */
        {
            j = sscanf(buffer, "%c%lf", &tmp, &CoordGeodetic->HeightAboveEllipsoid);
            if(j == 2)
                j = 1;
            Geoid->UseGeoid = 0;
        } else /* User entered height above MSL, convert it to the height above WGS-84 ellipsoid */
        {
            Geoid->UseGeoid = 1;
            j = sscanf(buffer, "%lf", &CoordGeodetic->HeightAboveGeoid);
            MAG_ConvertGeoidToEllipsoidHeight(CoordGeodetic, Geoid);
        }
        if(j == 1)
            done = 1;
        else
            printf("\nIllegal Format, please re-enter as '(-)HHH.hhh:'\n");
        if(CoordGeodetic->HeightAboveEllipsoid < -10.0 && done == 1)
            switch(MAG_Warnings(3, CoordGeodetic->HeightAboveEllipsoid, MagneticModel)) {
                case 0:
                    return 0;
                case 1:
                    done = 0;
                    printf("Please enter height above sea level (in kilometers):\n");
                    break;
                case 2:
                    break;
            }
    }
    strcpy(buffer, "");
    printf("\nPlease enter the decimal year or calendar date\n (YYYY.yyy, MM DD YYYY or MM/DD/YYYY):\n");
    fgets(buffer, 40, stdin);
    for(i = 0, done = 0; i <= 40 && !done; i++)
    {
        if(buffer[i] == '.')
        {
            j = sscanf(buffer, "%lf", &MagneticDate->DecimalYear);
            if(j == 1)
                done = 1;
            else
                buffer[i] = '\0';
        }
        if(buffer[i] == '/')
        {
            sscanf(buffer, "%d/%d/%d", &MagneticDate->Month, &MagneticDate->Day, &MagneticDate->Year);
            if(!MAG_DateToYear(MagneticDate, Error_Message))
            {
                printf(Error_Message);
                printf("\nPlease re-enter Date in MM/DD/YYYY or MM DD YYYY format, or as a decimal year\n");
                fgets(buffer, 40, stdin);
                i = 0;
            } else
                done = 1;
        }
        if((buffer[i] == ' ' && buffer[i + 1] != '/') || buffer[i] == '\0')
        {
            if(3 == sscanf(buffer, "%d %d %d", &a, &b, &c))
            {
                MagneticDate->Month = a;
                MagneticDate->Day = b;
                MagneticDate->Year = c;
                MagneticDate->DecimalYear = 99999;
            } else if(1 == sscanf(buffer, "%d %d %d", &a, &b, &c))
            {
                MagneticDate->DecimalYear = a;
                done = 1;
            }
            if(!(MagneticDate->DecimalYear == a))
            {
                if(!MAG_DateToYear(MagneticDate, Error_Message))
                {
                    printf(Error_Message);
                    strcpy(buffer, "");
                    printf("\nError encountered, please re-enter Date in MM/DD/YYYY or MM DD YYYY format, or as a decimal year\n");
                    fgets(buffer, 40, stdin);
                    i = -1;
                } else
                    done = 1;
            }
        }
        if(buffer[i] == '\0' && i != -1 && done != 1)
        {
            strcpy(buffer, "");
            printf("\nError encountered, please re-enter as MM/DD/YYYY, MM DD YYYY, or as YYYY.yyy:\n");
            fgets(buffer, 40, stdin);
            i = -1;
        }
        if(done)
        {
            if(MagneticDate->DecimalYear > MagneticModel->CoefficientFileEndDate || MagneticDate->DecimalYear < MagneticModel->epoch)
            {
                switch(MAG_Warnings(4, MagneticDate->DecimalYear, MagneticModel)) {
                    case 0:
                        return 0;
                    case 1:
                        done = 0;
                        i = -1;
                        strcpy(buffer, "");
                        printf("\nPlease enter the decimal year or calendar date\n (YYYY.yyy, MM DD YYYY or MM/DD/YYYY):\n");
                        fgets(buffer, 40, stdin);
                        break;
                    case 2:
                        break;
                }
            }
        }
    }
    return 1;
} /*MAG_GetUserInput*/

void MAG_PrintGradient(MAGtype_Gradient Gradient)
{
    printf("\nGradient\n");
    printf("\n                 Northward       Eastward        Downward\n");
    printf("X:           %7.1f nT/km %9.1f nT/km %9.1f nT/km \n", Gradient.GradPhi.X, Gradient.GradLambda.X, Gradient.GradZ.X);
    printf("Y:           %7.1f nT/km %9.1f nT/km %9.1f nT/km \n", Gradient.GradPhi.Y, Gradient.GradLambda.Y, Gradient.GradZ.Y);
    printf("Z:           %7.1f nT/km %9.1f nT/km %9.1f nT/km \n", Gradient.GradPhi.Z, Gradient.GradLambda.Z, Gradient.GradZ.Z);
    printf("H:           %7.1f nT/km %9.1f nT/km %9.1f nT/km \n", Gradient.GradPhi.H, Gradient.GradLambda.H, Gradient.GradZ.H);
    printf("F:           %7.1f nT/km %9.1f nT/km %9.1f nT/km \n", Gradient.GradPhi.F, Gradient.GradLambda.F, Gradient.GradZ.F);
    printf("Declination: %7.2f min/km %8.2f min/km %8.2f min/km \n", Gradient.GradPhi.Decl * 60, Gradient.GradLambda.Decl * 60, Gradient.GradZ.Decl * 60);
    printf("Inclination: %7.2f min/km %8.2f min/km %8.2f min/km \n", Gradient.GradPhi.Incl * 60, Gradient.GradLambda.Incl * 60, Gradient.GradZ.Incl * 60);
}

void MAG_PrintUserData(MAGtype_GeoMagneticElements GeomagElements, MAGtype_CoordGeodetic SpaceInput, MAGtype_Date TimeInput, MAGtype_MagneticModel *MagneticModel, MAGtype_Geoid *Geoid)
/* This function prints the results in  Geomagnetic Elements for a point calculation. It takes the calculated
 *  Geomagnetic elements "GeomagElements" as input.
 *  As well as the coordinates, date, and Magnetic Model.
INPUT :  GeomagElements : Data structure MAGtype_GeoMagneticElements with the following elements
                        double Decl; (Angle between the magnetic field vector and true north, positive east)
                        double Incl; Angle between the magnetic field vector and the horizontal plane, positive down
                        double F; Magnetic Field Strength
                        double H; Horizontal Magnetic Field Strength
                        double X; Northern component of the magnetic field vector
                        double Y; Eastern component of the magnetic field vector
                        double Z; Downward component of the magnetic field vector4
                        double Decldot; Yearly Rate of change in declination
                        double Incldot; Yearly Rate of change in inclination
                        double Fdot; Yearly rate of change in Magnetic field strength
                        double Hdot; Yearly rate of change in horizontal field strength
                        double Xdot; Yearly rate of change in the northern component
                        double Ydot; Yearly rate of change in the eastern component
                        double Zdot; Yearly rate of change in the downward component
                        double GVdot;Yearly rate of chnage in grid variation
        CoordGeodetic Pointer to the  data  structure with the following elements
                        double lambda; (longitude)
                        double phi; ( geodetic latitude)
                        double HeightAboveEllipsoid; (height above the ellipsoid (HaE) )
                        double HeightAboveGeoid;(height above the Geoid )
        TimeInput :  data structure MAGtype_Date with the following elements
                        int	Year;
                        int	Month;
                        int	Day;
                        double DecimalYear;      decimal years
        MagneticModel :	 data structure with the following elements
                        double EditionDate;
                        double epoch;       Base time of Geomagnetic model epoch (yrs)
                        char  ModelName[20];
                        double *Main_Field_Coeff_G;          C - Gauss coefficients of main geomagnetic model (nT)
                        double *Main_Field_Coeff_H;          C - Gauss coefficients of main geomagnetic model (nT)
                        double *Secular_Var_Coeff_G;  CD - Gauss coefficients of secular geomagnetic model (nT/yr)
                        double *Secular_Var_Coeff_H;  CD - Gauss coefficients of secular geomagnetic model (nT/yr)
                        int nMax;  Maximum degree of spherical harmonic model
                        int nMaxSecVar; Maxumum degree of spherical harmonic secular model
                        int SecularVariationUsed; Whether or not the magnetic secular variation vector will be needed by program
        OUTPUT : none
 */
{
    char DeclString[100];
    char InclString[100];
    MAG_DegreeToDMSstring(GeomagElements.Incl, 2, InclString);
    if(GeomagElements.H < 5000 && GeomagElements.H > 1000)
        MAG_Warnings(1, GeomagElements.H, MagneticModel);
    if(GeomagElements.H < 1000)
        MAG_Warnings(2, GeomagElements.H, MagneticModel);
    if(MagneticModel->SecularVariationUsed == TRUE)
    {
        MAG_DegreeToDMSstring(GeomagElements.Decl, 2, DeclString);
        printf("\n Results For \n\n");
        if(SpaceInput.phi < 0)
            printf("Latitude	%.2fS\n", -SpaceInput.phi);
        else
            printf("Latitude	%.2fN\n", SpaceInput.phi);
        if(SpaceInput.lambda < 0)
            printf("Longitude	%.2fW\n", -SpaceInput.lambda);
        else
            printf("Longitude	%.2fE\n", SpaceInput.lambda);
        if(Geoid->UseGeoid == 1)
            printf("Altitude:	%.2f Kilometers above mean sea level\n", SpaceInput.HeightAboveGeoid);
        else
            printf("Altitude:	%.2f Kilometers above the WGS-84 ellipsoid\n", SpaceInput.HeightAboveEllipsoid);
        printf("Date:		%.1f\n", TimeInput.DecimalYear);
        printf("\n		Main Field\t\t\tSecular Change\n");
        printf("F	=	%-9.1f nT\t\t  Fdot = %.1f\tnT/yr\n", GeomagElements.F, GeomagElements.Fdot);
        printf("H	=	%-9.1f nT\t\t  Hdot = %.1f\tnT/yr\n", GeomagElements.H, GeomagElements.Hdot);
        printf("X	=	%-9.1f nT\t\t  Xdot = %.1f\tnT/yr\n", GeomagElements.X, GeomagElements.Xdot);
        printf("Y	=	%-9.1f nT\t\t  Ydot = %.1f\tnT/yr\n", GeomagElements.Y, GeomagElements.Ydot);
        printf("Z	=	%-9.1f nT\t\t  Zdot = %.1f\tnT/yr\n", GeomagElements.Z, GeomagElements.Zdot);
        if(GeomagElements.Decl < 0)
            printf("Decl	=%20s  (WEST)\t  Ddot = %.1f\tMin/yr\n", DeclString, 60 * GeomagElements.Decldot);
        else
            printf("Decl	=%20s  (EAST)\t  Ddot = %.1f\tMin/yr\n", DeclString, 60 * GeomagElements.Decldot);
        if(GeomagElements.Incl < 0)
            printf("Incl	=%20s  (UP)\t  Idot = %.1f\tMin/yr\n", InclString, 60 * GeomagElements.Incldot);
        else
            printf("Incl	=%20s  (DOWN)\t  Idot = %.1f\tMin/yr\n", InclString, 60 * GeomagElements.Incldot);
    } else
    {
        MAG_DegreeToDMSstring(GeomagElements.Decl, 2, DeclString);
        printf("\n Results For \n\n");
        if(SpaceInput.phi < 0)
            printf("Latitude	%.2fS\n", -SpaceInput.phi);
        else
            printf("Latitude	%.2fN\n", SpaceInput.phi);
        if(SpaceInput.lambda < 0)
            printf("Longitude	%.2fW\n", -SpaceInput.lambda);
        else
            printf("Longitude	%.2fE\n", SpaceInput.lambda);
        if(Geoid->UseGeoid == 1)
            printf("Altitude:	%.2f Kilometers above MSL\n", SpaceInput.HeightAboveGeoid);
        else
            printf("Altitude:	%.2f Kilometers above WGS-84 Ellipsoid\n", SpaceInput.HeightAboveEllipsoid);
        printf("Date:		%.1f\n", TimeInput.DecimalYear);
        printf("\n	Main Field\n");
        printf("F	=	%-9.1f nT\n", GeomagElements.F);
        printf("H	=	%-9.1f nT\n", GeomagElements.H);
        printf("X	=	%-9.1f nT\n", GeomagElements.X);
        printf("Y	=	%-9.1f nT\n", GeomagElements.Y);
        printf("Z	=	%-9.1f nT\n", GeomagElements.Z);
        if(GeomagElements.Decl < 0)
            printf("Decl	=%20s  (WEST)\n", DeclString);
        else
            printf("Decl	=%20s  (EAST)\n", DeclString);
        if(GeomagElements.Incl < 0)
            printf("Incl	=%20s  (UP)\n", InclString);
        else
            printf("Incl	=%20s  (DOWN)\n", InclString);
    }

    if(SpaceInput.phi <= -55 || SpaceInput.phi >= 55)
        /* Print Grid Variation */
    {
        MAG_DegreeToDMSstring(GeomagElements.GV, 2, InclString);
        printf("\n\n Grid variation =%20s\n", InclString);
    }

}/*MAG_PrintUserData*/

int MAG_ValidateDMSstringlat(char *input, char *Error)

/* Validates a latitude DMS string, and returns 1 for a success and returns 0 for a failure.
It copies an error message to the Error string in the event of a failure.

INPUT : input (DMS string)
OUTPUT : Error : Error string
CALLS : none
 */
{
    int degree, minute, second, j = 0, n, max_minute = 60, max_second = 60;
    int i;
    degree = -1000;
    minute = -1;
    second = -1;
    n = (int) strlen(input);

    for(i = 0; i <= n - 1; i++) /*tests for legal characters*/
    {
        if((input[i] < '0' || input[i] > '9') && (input[i] != ',' && input[i] != ' ' && input[i] != '-' && input[i] != '\0' && input[i] != '\n'))
        {
            strcpy(Error, "\nError: Input contains an illegal character, legal characters for Degree, Minute, Second format are:\n '0-9' ',' '-' '[space]' '[Enter]'\n");
            return FALSE;
        }
        if(input[i] == ',')
            j++;
    }
    if(j == 2)
        j = sscanf(input, "%d, %d, %d", &degree, &minute, &second); /*tests for legal formatting and range*/
    else
        j = sscanf(input, "%d %d %d", &degree, &minute, &second);
    if(j == 1)
    {
        minute = 0;
        second = 0;
        j = 3;
    }
    if(j != 3)
    {
        strcpy(Error, "\nError: Not enough numbers used for Degrees, Minutes, Seconds format\n or they were incorrectly formatted\n The legal format is DD,MM,SS or DD MM SS\n");
        return FALSE;
    }
    if(degree > 90 || degree < -90)
    {
        strcpy(Error, "\nError: Degree input is outside legal range for latitude\n The legal range is from -90 to 90\n");
        return FALSE;
    }
    if(abs(degree) == 90)
        max_minute = 0;
    if(minute > max_minute || minute < 0)
    {
        strcpy(Error, "\nError: Minute input is outside legal range\n The legal minute range is from 0 to 60\n");
        return FALSE;
    }
    if(minute == max_minute)
        max_second = 0;
    if(second > max_second || second < 0)
    {
        strcpy(Error, "\nError: Second input is outside legal range\n The legal second range is from 0 to 60\n");
        return FALSE;
    }
    return TRUE;
} /*MAG_ValidateDMSstringlat*/

int MAG_ValidateDMSstringlong(char *input, char *Error)

/*Validates a given longitude DMS string and returns 1 for a success and returns 0 for a failure.
It copies an error message to the Error string in the event of a failure.

INPUT : input (DMS string)
OUTPUT : Error : Error string
CALLS : none

 */
{
    int degree, minute, second, j = 0, max_minute = 60, max_second = 60, n;
    int i;
    degree = -1000;
    minute = -1;
    second = -1;
    n = (int) strlen(input);

    for(i = 0; i <= n - 1; i++) /* tests for legal characters */
    {
        if((input[i] < '0' || input[i] > '9') && (input[i] != ',' && input[i] != ' ' && input[i] != '-' && input[i] != '\0' && input[i] != '\n'))
        {
            strcpy(Error, "\nError: Input contains an illegal character, legal characters for Degree, Minute, Second format are:\n '0-9' ',' '-' '[space]' '[Enter]'\n");
            return FALSE;
        }
        if(input[i] == ',')
            j++;
    }
    if(j >= 2)
        j = sscanf(input, "%d, %d, %d", &degree, &minute, &second); /* tests for legal formatting and range */
    else
        j = sscanf(input, "%d %d %d", &degree, &minute, &second);
    if(j == 1)
    {
        minute = 0;
        second = 0;
        j = 3;
    }
    if(j != 3)
    {
        strcpy(Error, "\nError: Not enough numbers read for Degrees, Minutes, Seconds format\n or they were incorrectly formatted\n The legal format is DD,MM,SS or DD MM SS\n");
        return FALSE;
    }
    sscanf(input, "%d, %d, %d", &degree, &minute, &second); /* tests for legal formatting and range */
    if(degree > 360 || degree < -180)
    {
        strcpy(Error, "\nError: Degree input is outside legal range\n The legal range is from -180 to 360\n");
        return FALSE;
    }
    if(degree == 360 || degree == -180)
        max_minute = 0;
    if(minute > max_minute || minute < 0)
    {
        strcpy(Error, "\nError: Minute input is outside legal range\n The legal minute range is from 0 to 60\n");
        return FALSE;
    }
    if(minute == max_minute)
        max_second = 0;
    if(second > max_second || second < 0)
    {
        strcpy(Error, "\nError: Second input is outside legal range\n The legal second range is from 0 to 60\n");
        return FALSE;
    }
    return TRUE;
} /*MAG_ValidateDMSstringlong*/

int MAG_Warnings(int control, double value, MAGtype_MagneticModel *MagneticModel)

/*Return value 0 means end program, Return value 1 means get new data, Return value 2 means continue.
  This prints a warning to the screen determined by the control integer. It also takes the value of the parameter causing the warning as a double.  This is unnecessary for some warnings.
  It requires the MagneticModel to determine the current epoch.

 INPUT control :int : (Warning number)
                value  : double: Magnetic field strength
                MagneticModel
OUTPUT : none
CALLS : none

 */
{
    char ans[20];
    strcpy(ans, "");
    switch(control) {
        case 1:/* Horizontal Field strength low */
            printf("\nWarning: The Horizontal Field strength at this location is only %f\n", value);
            printf("	Compass readings have large uncertainties in areas where H\n	is smaller than 5000 nT\n");
            printf("Press enter to continue...\n");
            fgets(ans, 20, stdin);
            break;
        case 2:/* Horizontal Field strength very low */
            printf("\nWarning: The Horizontal Field strength at this location is only %f\n", value);
            printf("	Compass readings have VERY LARGE uncertainties in areas where\n	where H is smaller than 1000 nT\n");
            printf("Press enter to continue...\n");
            fgets(ans, 20, stdin);
            break;
        case 3:/* Elevation outside the recommended range */
            printf("\nWarning: The value you have entered of %f km for the elevation is outside of the recommended range.\n Elevations above -10.0 km are recommended for accurate results. \n", value);
            while(1)
            {
                printf("\nPlease press 'C' to continue, 'G' to get new data or 'X' to exit...\n");
                fgets(ans, 20, stdin);
                switch(ans[0]) {
                    case 'X':
                    case 'x':
                        return 0;
                    case 'G':
                    case 'g':
                        return 1;
                    case 'C':
                    case 'c':
                        return 2;
                    default:
                        printf("\nInvalid input %c\n", ans[0]);
                        break;
                }
            }
            break;

        case 4:/*Date outside the recommended range*/
            printf("\nWARNING - TIME EXTENDS BEYOND INTENDED USAGE RANGE\n CONTACT NGDC FOR PRODUCT UPDATES:\n");
            printf("	National Geophysical Data Center\n");
            printf("	NOAA EGC/2\n");
            printf("	325 Broadway\n");
            printf("	Attn: Manoj Nair or Arnaud Chulliat\n");
            printf("	Phone:	(303) 497-4642 or -6522\n");
            printf("	Email:	geomag.models@noaa.gov\n");
            printf("	Web: http://www.ngdc.noaa.gov/Geomagnetic/WMM/DoDWMM.shtml\n");
            printf("\n VALID RANGE  = %d - %d\n", (int) MagneticModel->epoch, (int) MagneticModel->CoefficientFileEndDate);
            printf(" TIME   = %f\n", value);
            while(1)
            {
                printf("\nPlease press 'C' to continue, 'N' to enter new data or 'X' to exit...\n");
                fgets(ans, 20, stdin);
                switch(ans[0]) {
                    case 'X':
                    case 'x':
                        return 0;
                    case 'N':
                    case 'n':
                        return 1;
                    case 'C':
                    case 'c':
                        return 2;
                    default:
                        printf("\nInvalid input %c\n", ans[0]);
                        break;
                }
            }
            break;
    }
    return 2;
} /*MAG_Warnings*/

/*End of User Interface functions*/


void MAG_PrintWMMFormat(char *filename, MAGtype_MagneticModel *MagneticModel)
{
    int index, n, m;
    FILE *OUT;
    MAGtype_Date Date;
    char Datestring[11];

    Date.DecimalYear = MagneticModel->EditionDate;
    MAG_YearToDate(&Date);
    sprintf(Datestring, "%d/%d/%d", Date.Month, Date.Day, Date.Year);
    OUT = fopen(filename, "w");
    fprintf(OUT, "    %.1f               %s              %s\n", MagneticModel->epoch, MagneticModel->ModelName, Datestring);
    for(n = 1; n <= MagneticModel->nMax; n++)
    {
        for(m = 0; m <= n; m++)
        {
            index = (n * (n + 1) / 2 + m);
            if(m != 0)
                fprintf(OUT, " %2d %2d %9.4f %9.4f  %9.4f %9.4f\n", n, m, MagneticModel->Main_Field_Coeff_G[index], MagneticModel->Main_Field_Coeff_H[index], MagneticModel->Secular_Var_Coeff_G[index], MagneticModel->Secular_Var_Coeff_H[index]);
            else
                fprintf(OUT, " %2d %2d %9.4f %9.4f  %9.4f %9.4f\n", n, m, MagneticModel->Main_Field_Coeff_G[index], 0.0, MagneticModel->Secular_Var_Coeff_G[index], 0.0);
        }
    }
    fclose(OUT);
} /*MAG_PrintWMMFormat*/

void MAG_PrintEMMFormat(char *filename, char *filenameSV, MAGtype_MagneticModel *MagneticModel)
{
    int index, n, m;
    FILE *OUT;
    MAGtype_Date Date;
    char Datestring[11];

    Date.DecimalYear = MagneticModel->EditionDate;
    MAG_YearToDate(&Date);
    sprintf(Datestring, "%d/%d/%d", Date.Month, Date.Day, Date.Year);
    OUT = fopen(filename, "w");
    fprintf(OUT, "    %.1f               %s              %s\n", MagneticModel->epoch, MagneticModel->ModelName, Datestring);
    for(n = 1; n <= MagneticModel->nMax; n++)
    {
        for(m = 0; m <= n; m++)
        {
            index = (n * (n + 1) / 2 + m);
            if(m != 0)
                fprintf(OUT, " %2d %2d %9.4f %9.4f\n", n, m, MagneticModel->Main_Field_Coeff_G[index], MagneticModel->Main_Field_Coeff_H[index]);
            else
                fprintf(OUT, " %2d %2d %9.4f %9.4f\n", n, m, MagneticModel->Main_Field_Coeff_G[index], 0.0);
        }
    }
    fclose(OUT);
    OUT = fopen(filenameSV, "w");
    for(n = 1; n <= MagneticModel->nMaxSecVar; n++)
    {
        for(m = 0; m <= n; m++)
        {
            index = (n * (n + 1) / 2 + m);
            if(m != 0)
                fprintf(OUT, " %2d %2d %9.4f %9.4f\n", n, m, MagneticModel->Secular_Var_Coeff_G[index], MagneticModel->Secular_Var_Coeff_H[index]);
            else
                fprintf(OUT, " %2d %2d %9.4f %9.4f\n", n, m, MagneticModel->Secular_Var_Coeff_G[index], 0.0);
        }
    }
    fclose(OUT);
    return;
} /*MAG_PrintEMMFormat*/

void MAG_PrintSHDFFormat(char *filename, MAGtype_MagneticModel *(*MagneticModel)[], int epochs)
{
    	int i, n, m, index, epochRange;
	FILE *SHDF_file;
	SHDF_file = fopen(filename, "w");
	/*lines = (int)(UFM_DEGREE / 2.0 * (UFM_DEGREE + 3));*/
	for(i = 0; i < epochs; i++)
	{
            if(i < epochs - 1) epochRange = (*MagneticModel)[i+1]->epoch - (*MagneticModel)[i]->epoch;
            else epochRange = (*MagneticModel)[i]->epoch - (*MagneticModel)[i-1]->epoch;
            fprintf(SHDF_file, "%%SHDF 16695 Definitive Geomagnetic Reference Field Model Coefficient File\n");
		fprintf(SHDF_file, "%%ModelName: %s\n", (*MagneticModel)[i]->ModelName);
		fprintf(SHDF_file, "%%Publisher: International Association of Geomagnetism and Aeronomy (IAGA), Working Group V-Mod\n");
		fprintf(SHDF_file, "%%ReleaseDate: Some Number\n");
		fprintf(SHDF_file, "%%DataCutOFF: Some Other Number\n");
		fprintf(SHDF_file, "%%ModelStartYear: %d\n", (int)(*MagneticModel)[i]->epoch);
		fprintf(SHDF_file, "%%ModelEndYear: %d\n", (int)(*MagneticModel)[i]->epoch+epochRange);
		fprintf(SHDF_file, "%%Epoch: %.0f\n", (*MagneticModel)[i]->epoch);
		fprintf(SHDF_file, "%%IntStaticDeg: %d\n", (*MagneticModel)[i]->nMax);
		fprintf(SHDF_file, "%%IntSecVarDeg: %d\n", (*MagneticModel)[i]->nMaxSecVar);
		fprintf(SHDF_file, "%%ExtStaticDeg: 0\n");
		fprintf(SHDF_file, "%%ExtSecVarDeg: 0\n");
		fprintf(SHDF_file, "%%Normalization: Schmidt semi-normailized\n");
		fprintf(SHDF_file, "%%SpatBasFunc: spherical harmonics\n"); 
		fprintf(SHDF_file, "# To synthesize the field for a given date:\n");
		fprintf(SHDF_file, "# Use the sub-model of the epoch corresponding to each date\n");
		fprintf(SHDF_file, "#\n#\n#\n#\n# I/E, n, m, Gnm, Hnm, SV-Gnm, SV-Hnm\n#\n");
		n = 1;
		m = 0;
		for(n = 1; n <= (*MagneticModel)[i]->nMax; n++)
		{
			for(m = 0; m <= n; m++)
			{
				index = (n * (n+1)) / 2 + m;
				if(i < epochs - 1)
				{
					if(m != 0)
						fprintf(SHDF_file, "I,%d,%d,%f,%f,%f,%f\n", n, m, (*MagneticModel)[i]->Main_Field_Coeff_G[index], (*MagneticModel)[i]->Main_Field_Coeff_H[index], (*MagneticModel)[i]->Secular_Var_Coeff_G[index], (*MagneticModel)[i]->Secular_Var_Coeff_H[index]);
					else
						fprintf(SHDF_file, "I,%d,%d,%f,,%f,\n", n, m, (*MagneticModel)[i]->Main_Field_Coeff_G[index], (*MagneticModel)[i]->Secular_Var_Coeff_G[index]);
				}
				else
				{
					if(m != 0)
						fprintf(SHDF_file, "I,%d,%d,%f,%f,%f,%f\n", n, m, (*MagneticModel)[i]->Main_Field_Coeff_G[index], (*MagneticModel)[i]->Main_Field_Coeff_H[index], (*MagneticModel)[i]->Secular_Var_Coeff_G[index], (*MagneticModel)[i]->Secular_Var_Coeff_H[index]);
					else
						fprintf(SHDF_file, "I,%d,%d,%f,,%f,\n", n, m, (*MagneticModel)[i]->Main_Field_Coeff_G[index], (*MagneticModel)[i]->Secular_Var_Coeff_G[index]);
				}
			}
		}
	}
} /*MAG_PrintSHDFFormat*/

int MAG_readMagneticModel_Large(char *filename, char *filenameSV, MAGtype_MagneticModel *MagneticModel)

/*  To read the high-degree model coefficients (for example, NGDC 720)
   INPUT :  filename   file name for static coefficients
                        filenameSV file name for secular variation coefficients

                        MagneticModel : Pointer to the data structure with the following fields required as inputs
                                nMaxSecVar : Number of secular variation coefficients
                                nMax : 	Number of static coefficients
   UPDATES : MagneticModel : Pointer to the data structure with the following fields populated
                                double epoch;       Base time of Geomagnetic model epoch (yrs)
                                double *Main_Field_Coeff_G;          C - Gauss coefficients of main geomagnetic model (nT)
                                double *Main_Field_Coeff_H;          C - Gauss coefficients of main geomagnetic model (nT)
                                double *Secular_Var_Coeff_G;  CD - Gauss coefficients of secular geomagnetic model (nT/yr)
                                double *Secular_Var_Coeff_H;  CD - Gauss coefficients of secular geomagnetic model (nT/yr)
        CALLS : none

 */
{
    FILE *MAG_COF_File;
    FILE *MAG_COFSV_File;
    char c_str[81], c_str2[81]; /* these strings are used to read a line from coefficient file */
    int i, m, n, index, a, b;
    double epoch, gnm, hnm, dgnm, dhnm;
    MAG_COF_File = fopen(filename, "r");
    MAG_COFSV_File = fopen(filenameSV, "r");
    if(MAG_COF_File == NULL || MAG_COFSV_File == NULL)
    {
        MAG_Error(20);
        return FALSE;
    }
    MagneticModel->Main_Field_Coeff_H[0] = 0.0;
    MagneticModel->Main_Field_Coeff_G[0] = 0.0;
    MagneticModel->Secular_Var_Coeff_H[0] = 0.0;
    MagneticModel->Secular_Var_Coeff_G[0] = 0.0;
    fgets(c_str, 80, MAG_COF_File);
    sscanf(c_str, "%lf%s", &epoch, MagneticModel->ModelName);
    MagneticModel->epoch = epoch;
    a = CALCULATE_NUMTERMS(MagneticModel->nMaxSecVar);
    b = CALCULATE_NUMTERMS(MagneticModel->nMax);
    for(i = 0; i < a; i++)
    {
        fgets(c_str, 80, MAG_COF_File);
        sscanf(c_str, "%d%d%lf%lf", &n, &m, &gnm, &hnm);
        fgets(c_str2, 80, MAG_COFSV_File);
        sscanf(c_str2, "%d%d%lf%lf", &n, &m, &dgnm, &dhnm);
        if(m <= n)
        {
            index = (n * (n + 1) / 2 + m);
            MagneticModel->Main_Field_Coeff_G[index] = gnm;
            MagneticModel->Secular_Var_Coeff_G[index] = dgnm;
            MagneticModel->Main_Field_Coeff_H[index] = hnm;
            MagneticModel->Secular_Var_Coeff_H[index] = dhnm;
        }
    }
    for(i = a; i < b; i++)
    {
        fgets(c_str, 80, MAG_COF_File);
        sscanf(c_str, "%d%d%lf%lf", &n, &m, &gnm, &hnm);
        if(m <= n)
        {
            index = (n * (n + 1) / 2 + m);
            MagneticModel->Main_Field_Coeff_G[index] = gnm;
            MagneticModel->Main_Field_Coeff_H[index] = hnm;
        }
    }
    if(MAG_COF_File != NULL && MAG_COFSV_File != NULL)
    {
        fclose(MAG_COF_File);
        fclose(MAG_COFSV_File);
    }

    return TRUE;
} /*MAG_readMagneticModel_Large*/


/******************************************************************************
 *************Conversions, Transformations, and other Calculations**************
 * This grouping consists of functions that perform unit conversions, coordinate
 * transformations and other simple or straightforward calculations that are 
 * usually easily replicable with a typical scientific calculator. 
 ******************************************************************************/


void MAG_BaseErrors(double DeclCoef, double DeclBaseline, double InclOffset, double FOffset, double Multiplier, double H, double* DeclErr, double* InclErr, double* FErr)
{
    double declHorizontalAdjustmentSq;
    declHorizontalAdjustmentSq = (DeclCoef/H) * (DeclCoef/H);
    *DeclErr = sqrt(declHorizontalAdjustmentSq + DeclBaseline*DeclBaseline) * Multiplier;
    *InclErr = InclOffset*Multiplier;
    *FErr = FOffset*Multiplier;
}


int MAG_CalculateGridVariation(MAGtype_CoordGeodetic location, MAGtype_GeoMagneticElements *elements)

/*Computes the grid variation for |latitudes| > MAG_MAX_LAT_DEGREE

Grivation (or grid variation) is the angle between grid north and
magnetic north. This routine calculates Grivation for the Polar Stereographic
projection for polar locations (Latitude => |55| deg). Otherwise, it computes the grid
variation in UTM projection system. However, the UTM projection codes may be used to compute
the grid variation at any latitudes.

INPUT    location    Data structure with the following elements
                double lambda; (longitude)
                double phi; ( geodetic latitude)
                double HeightAboveEllipsoid; (height above the ellipsoid (HaE) )
                double HeightAboveGeoid;(height above the Geoid )
OUTPUT  elements Data  structure with the following elements updated
                double GV; ( The Grid Variation )
CALLS : MAG_GetTransverseMercator

 */
{
    MAGtype_UTMParameters UTMParameters;
    if(location.phi >= MAG_PS_MAX_LAT_DEGREE)
    {
        elements->GV = elements->Decl - location.lambda;
        return 1;
    } else if(location.phi <= MAG_PS_MIN_LAT_DEGREE)
    {
        elements->GV = elements->Decl + location.lambda;
        return 1;
    } else
    {
        MAG_GetTransverseMercator(location, &UTMParameters);
        elements->GV = elements->Decl - UTMParameters.ConvergenceOfMeridians;
    }
    return 0;
} /*MAG_CalculateGridVariation*/
